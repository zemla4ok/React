Redux – это стабильный (предсказуемый) контейнер для хранения состояния JavaScript-приложений, основанный на паттерне проектирова- ния Flux. Redux может использоваться с React и любой другой библиотекой. Он легкий (около 2 Кб) и не имеет зависимостей.
Чтобы поключить Redux к нашему приложению необходимо установить 2 библиотеки – сам redux и react-redux.

Преимущества
•Хранилище позволяет любому компоненту получать состояние без передачи пропсов
•Состояние сохраняется даже при размонтировании компонента
•Предотвращает ненужные повторные рендеринги благодаря поверхностному сравнению нового и старого состояния
•Разделение UI и управления данными облегчает тестирование
•Сохраняется история изменения состояния, что позволяет легко повторять или отменять операции

Недостатки
•Отсутствует инкапсуляция. Любой компонент имеет доступ к данным, что может привести к проблемам с безопасностью
•Много шаблонного кода. Ограниченный дизайн
•Поскольку состояние является иммутабельным, reducer обновляет его, каждый раз возвращая новое состояние, что влечет дополнительные расходы памяти


Принципы
•Единственный источник истины – состояние всего приложения хранится в древовидном объекта - в одном хранилище. Единственное состояние-дерево облегчает наблюдение за изменениями и отладку или инспектирование приложения.
•Состояние доступно только для чтения – единственный способ изменить состояние заключается в запуске операции – объекте, описывающем произошедшее. Это позволяет гарантировать, что ни представления, ни сетевые коллбеки не буду иметь возможности изменять состояние напрямую.
•Изменения производятся с помощью "чистых" функций – для определения того, как изменяется состояние в зависимости от операции, создаются редукторы (reducers). Редукторы – это "чистые" функции, принимающие предыдущее состояние в качестве аргумента и возвращающие новое


Как работает
Имеется центральное хранилище, содержащее состояние приложения. Каждый компонент имеет доступ к этому хранилищу, так что нет необходимости передавать пропы из одного компонента в другой. Существует три строительных блока: хранилище, редукторы (reducers) и операции (actions).


Action (операция) – это статическая информация о событии, инициализирующем изменение состояния. Обновление состояния в Redux всегда начинается с операции. Операции – это объекты, содержащие обязательное свойство type и опциональное свойство payload. Операции вызываются с помощью метода store.dispatch(). Операция создается с помощью "создателя операций" (action creator).
Создатели операций – функции, помогающие создавать операции. Создатель операции возвращает объект операции, который передается редуктору (reducer).


Reducers (редукторы) – это "чистые" функции, принимающие текущее состояние приложения, выполняющие над ним операцию и возвращающие новое состояние. Новое состояние – объект, описывающий изменения состояния, произошедшие в ответ на вызванную операцию.
Это похоже на функцию reduce() в JavaScript, когда значение вычисляется на основе нескольких значений после выполнения коллбека.
В React Redux можно создавать несколько reducer’ов и преобразовать их в один с помощью функции combineReducers().



В React Redux можно создавать несколько reducer’ов и преобразовать их в один с помощью функции combineReducers().
Создание нескольких редукторов иногда очень удобно когда у нас приложение состоит из нескольких семантически независимых частей. Напиример у нас интернет-магазин в котором есть и каталог товаров и корзина и личный кабинет пользователя. Чтобы не смешивать все обработчики в одном редукторе, куда читаемей и проще в обслуживании кода будет разбить это на отдельные редукторы, а потом это все обьеденить и передать в наш createStore().



State (еще называют Store) – это объект, содержащий состояние приложения. При обновлении состояния, обновляются все подписанные на него компоненты. Хранилище отвечает за запись, чтение и обновление состояния.
Store в react-redux создается с помощью функции createStore(). Которая принимает в себя reducer.
После того как мы создали Store. Мы передаем его в Provider который должен оборачивать все наше приложение, либо ту часть которой необходимо дать доступ к нашему Redux.
Provider – это компонент, содержащий ссылку на хранилище и передающий данные из хранилища дочерним компонентам.




connect – используется для создания компонентов-контейнеров, которые подключены к хранилищу Redux. Хранилище, к которому осуществляется подключение, получают от самого верхнего предка компонента с использованием механизма контекста React.
Функция connect возвращает компоент высшего порядка (HOC) который оборачивает наш компонент и таким образом мы получаем компонент уже подключенный к нашему Redux.
В качестве параметров функция connect принимает два аргумента:
•  mapStateToProps()
•  mapDispatchToProps()


Аргумент mapStateToProps является функцией, которая возвращает либо обычный объект, либо другую функцию. Передача этого аргумента connect() приводит к подписке компонента-контейнера на обновления хранилища Redux. Это означает, что функция mapStateToProps будет вызываться каждый раз, когда состояние хранилища изменяется.
Если вам слежение за обновлениями состояния не интересно, передайте connect() в качестве значения этого аргумента null.   Функция mapStateToProps объявляется с двумя параметрами, второй из которых является необязательным. Первый параметр представляет собой текущее состояние хранилища Redux. Второй параметр, если его передают, представляет собой объект свойств, переданных компоненту.
Если из mapStateToProps будет возвращён обычный объект, то возвращённый объект stateProps объединяется со свойствами компонента.
Если же mapStateToProps возвращает функцию, то эта функция используется как mapStateToProps для каждого экземпляра компонента. Это может пригодиться для улучшения производительности рендеринга и для мемоизации.




Если обьяснить простыми словами то mapDispatchToProps “подключает” наши action’ы к пропcам React-компонента.
Каждая функция переданная в объект mapDispatchToProps будет воспринята в качестве генератора действий Redux и обёрнута в вызов метода store’а dispatch().
После этого нашему компоненту из пропсов будут доступны эти функции как функции изменения состояния Redux.



useSelector приблизительно эквивалентен mapStateToProps. В качестве аргумента селектор будет передавать Redux state и будет вызываться когда компонент перерендеривается, так же он подписывается на store и вызывается каждый раз при изменении.
Однако селектор будет производить сравнение (по умолчанию является строгим ===) предыдущего значения результата селектора и текущего значения результата. Если они отличаются, компонент будет вынужден повторно выполнить рендеринг.
С useSelector возвращение нового объекта каждый раз по умолчанию будет вызывать повторный рендеринг.   Одним из вариантов возможно использование shallowEqual функции из React-Redux в качестве второго аргумента useSelector().

useDispatch
Этот хук возвращает ссылку на dispatch функцию из Redux. Вы можете использовать его для отправки действий.


Middleware (посредники) – это функции, которые вызываются последовательно в процессе обновления store.
Они встраиваются в хранилище при его создании и потом при диспатчинге данные проходят через них, до попадания в reducer.
Посредники используются для отправки асинхронных action’ов.
Для подключения middleware’ов используется функция applyMiddleware. В которую мы передаем нашы middleware’ы и потом передаем вторым аргументом в функцию createStore.





=============================


Autorun creates a reaction that runs once, and after that automatically re-runs whenever any observable data that was used inside the function changes. 
Because report uses the observable todos property, it will print the report whenever appropriate. This is demonstrated in the next listing.







